import { createClient } from '@/lib/supabase/server';
import { Database } from '@/types/supabase';
import { isDebugMode } from '@/lib/utils/debug';

// Use the Row type generated by Supabase CLI
export type VocabularyItem = Database['public']['Tables']['vocabulary_entries']['Row'];

const DEBUG_VOCAB = isDebugMode('VOCAB');

/**
 * Service for interacting with vocabulary data
 */
export class VocabularyService {
    /**
   * Get random vocabulary items matching criteria using the RPC function.
   * Note: Assumes the RPC function `get_random_vocabulary` exists and is updated 
   *       to work correctly with the new schema (especially theme joining).
     */
  async getVocabularyItems(params: {
    language: string;
    limit?: number;
    pos?: string[];
    cefrLevel?: string;
    themes?: string[];
  }): Promise<VocabularyItem[]> {
    const { language, limit = 10, pos, cefrLevel, themes } = params;
    if (DEBUG_VOCAB) console.log(`[Vocab Service] Fetching vocab:`, params);

    const supabase = await createClient();
    
    // TEMPORARY SIMPLIFIED IMPLEMENTATION: Just get random words
    // Ignore most constraints except for language and limit
    const { data, error } = await supabase
      .from('vocabulary_entries')
      .select('*')
      .eq('language_code', language)
      .order('id') // Using order instead of random() for better performance
      .limit(limit);

    if (error) {
      console.error('Error fetching vocabulary:', error);
      throw new Error(`Failed to fetch vocabulary: ${error.message}`);
    }

    if (DEBUG_VOCAB) console.log(`[Vocab Service] Fetched ${data?.length || 0} items using simplified method.`);
    
    return data || [];
    
    // ORIGINAL IMPLEMENTATION (COMMENTED OUT)
    /*
    // Call the updated RPC function
    const { data, error } = await supabase.rpc('get_random_vocabulary', {
      p_language: language,
      p_limit: limit,
      p_pos: pos,
      p_cefr_level: cefrLevel,
      p_themes: themes,
    });

    if (error) {
      console.error('Error fetching vocabulary from RPC:', error);
      throw new Error(`Failed to fetch vocabulary: ${error.message}`);
    }

    if (DEBUG_VOCAB) console.log(`[Vocab Service] Fetched ${data?.length || 0} items.`);
    
    // The RPC function now returns the correct type directly
    return data || [];
    */
  }

  // --- Add new methods for interacting with the relational structure (Examples) --- 

  // Example: Get translations for a specific vocabulary entry ID
  async getTranslations(entryId: number) {
    const supabase = await createClient();
    const { data, error } = await supabase
      .from('translations')
      .select(`
        relationship_type,
        context_notes,
        entry2:vocabulary_entries!entry_id_2 (*)
      `)
      .eq('entry_id_1', entryId);

        if (error) {
       console.error('Error fetching translations:', error);
            return [];
        }
    return data;
  }
  
  // Example: Get usage examples for a specific vocabulary entry ID
  async getUsageExamples(entryId: number) {
    const supabase = await createClient();
    const { data, error } = await supabase
      .from('usage_examples')
      .select('*')
      .eq('vocabulary_entry_id', entryId);
      
    if (error) {
       console.error('Error fetching usage examples:', error);
       return [];
    }
    return data;
    }
}

// Create a singleton instance
export const vocabularyService = new VocabularyService();

// console.log("DEBUG: vocabulary.service.ts loaded"); 